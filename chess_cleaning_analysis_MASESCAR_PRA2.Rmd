---
title: 'Tipología: PRA2 - Limpieza y análisis de un juego de datos'
author: "Autor: Carlos Mas Estevez"
date: "Junio 2022"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
    includes:
      in_header: 75.584-PEC-header.html
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_libraries, include=FALSE}
library(knitr)
library(readr)
library(dplyr)
library(stringr)
library(reshape)
library(ggplot2)
library(VIM)
library(nortest)
library(car)
library(MASS)
library(mlogit)
library(tidyr)
library(modeest)
library(report)
library(agricolae, warn.conflicts = FALSE)
library(ggpubr)
library(descr)
library(arules)
library(factoextra)
library(corrplot)
library(Stat2Data)
library(cluster)
library(palmerpenguins)
library(dbscan)
library(fpc)
```



******
******
******
******
******
******


# Resolución de la práctica 1


******


## Descripción del origen del conjunto de datos


Centraremos nuestro estudio en el análisis de un juego de datos con información relativa a más de 20000 partidas de ajedrez. La base de datos es de uso libre (CC0 1.0 Universal Public Domain Dedication) y se llama "Chess Game Dataset (Lichess)". 

Se puede obtener a través de Google Dataset Search:

https://datasetsearch.research.google.com/search?src=0&query=chess&docid=L2cvMTFqOWJ0MnJuNw%3D%3D

o bien desde Kaggle:

https://www.kaggle.com/datasets/datasnaek/chess



La motivacón de nuestra investigación radica en la obtención de información acerca de las condiciones de victoria de partidas de ajedrez según determinados factores, tales como la puntuación ELO de cada jugador, la duración de la partida o el tipo de apertura (combinación inicial de movimientos). La elección de esta base de datos se debe a que ofrece una gran cantidad de datos a los que se les podrán aplicar técnicas supervisadas (y no supervisadas) a fin de extraer conclusiones en base al estudio de distintos atributos que podrían condicionar la victoria de algún jugador. Al ser el jugador blanco el primero en realizar una jugada, resultará interesante saber cómo de relevante será este hecho a la hora de condicionar su victoria.

Para cada uno de estos juegos separados de Lichess, se recopiló estos datos utilizando la API de Lichess, que permite la recopilación del historial de juegos de cualquier usuario dado. Mucha información está contenida dentro de un solo juego de ajedrez, y más aún en un conjunto de datos completo con múltiples partidas. La ciencia de datos se trata de detectar patrones en los datos, y al tratarse el ajedrez de un juego principalmente de patrones, ha sido uno de los más usados en áreas de IA en el pasado. Este conjunto de datos recopila toda la información disponible de 20058 juegos y la presenta en un formato que es fácil de procesar para el análisis de, por ejemplo, lo que permite a un jugador ganar como blanco o negro, cuánto afectan los factores meta (fuera del juego) a un juego, la relación entre las aperturas y la victoria para blanco y negro, etc.

Varias preguntas que nos podríamos plantear a la hora de extraer conclusiones acerca de obtener victorias en partidas de ajedrez son: ¿Hasta qué punto es relevante la diferencia en puntuación ELO para poder predecir el ganador? ¿Existe una clara ventaja del equipo blanco en las partidas rápidas (poco tiempo de juego)? ¿Existe alguna apertura que influya en la condición de victoria en alguno de los jugadores? ¿Las partidas clasificadas (rated) suelen ser más conservadoras en las aperturas?

Mediante inspecciones visuales, tales como los histogramas o los boxplot, nos haremos una idea inicial de la distribucción de las partidas ganadas según determinados factores a fin de detectar tendencias. A la vez, realizaremos pruebas de covarianza y filtrado de datos para determinar más claramente las dependencias entre diferentes variables, así como un breve estudio de PCA.


```{r chunck1}
# Cargamos los datos del documento "games.csv" que contiene más de 20000 registros 
# de partidas de ajedrez

chess = read.csv("games.csv")
```


A continuación, mostramos un breve resumen de la tipología de los datos y su naturaleza a fin de verificar su estructura.


```{r chunck2}
# Visualizamos la estructura de las columnas de nuestro dataset

structure = str(chess)
```

Tenemos un total de 20058 registros y 16 variables, las cuales explicamos a continuación:

- **id**: identificador partida
- **rated**: partida competitiva o amistosa (TRUE = competitiva / FALSE = amistosa)
- **created_at**: Tiempo de inicio de la partida
- **last_move_at**: Tiempo de final de la partida
- **turns**: número de turnos
- **victory_status**: condición de victoria (abandono, tiempo agotado, victoria común, tablas, etc.)
- **winner**: indica el jugador ganador (white/black), o tablas
- **increment_code**: cantidad de tiempo de la partida e incremento por turno.
- **white_id**: identificador de jugador blanco.
- **white_rating**: puntuación ELO jugador blanco.
- **black_id**: identificador de jugador negro.
- **black_rating**: puntuación ELO jugador negro.
- **moves**: movimientos de la partida en Standard Chess Notation.
- **opening_eco**: Código estandarizado de la apertura (https://www.365chess.com/eco.php)
- **opening_name**: Nombre de la apertura.
- **opening_ply**: Número de movimientos de la fase de apertura.



## Preprocesamiento y gestión de características


Procedemos a hacer limpieza de datos, por lo que veremos en primer lugar si existen valores NA o en blanco en alguno de los atributos:

```{r chunck3}
# Comprobamos si hay valores NA

colSums(is.na(chess))
```

```{r chunck4}
# Comprobamos si hay valores NA

colSums(chess=="")
```

Observamos que no existen valores NA ni blancos en ninguno de los atributos, por lo que de momento no borraremos ningún registro.


En primer lugar, nos dispondremos a limpiar la variable *increment_code*, la cual tiene el siguiente formato:

```{r}
# Muestra de valores de la variable increment_code 

head(chess$increment_code)
tail(chess$increment_code)
```

Este formato de la variable *increment_code* indica el tiempo inicial (en minutos) designado para la partida + un incremento de tiempo en segundos por cada jugada realizada. Por ejemplo, si una partida se juega con 5+10 significa que inicialmente cada jugador tiene 5 minutos de reloj para jugar la partida, más un incremento de 10 segundos por cada jugada realizada. Es decir, si un jugador invierte 1 minuto en una jugada, le quedarán 4 minutos + 10 segundos de incremento para la siguiente jugada que realice.

Así pues, vamos a separar la variable *increment_code* (carácter) en dos variables numéricas para poder manipular mejor los datos: el tiempo inicial de partida en minutos (*time*) y el incremento en  segundos (*increment*):


```{r}
# Creación de las variables *time* y *increment* a partir de *increment_code*

chess$time <- as.integer( str_match(chess$increment_code, '\\w+') )

chess$increment <- as.integer( chartr("+", " ", str_match(chess$increment_code, '\\+\\w+')) )
```

Hacemos un barplot de la variable *time* para detectar posibles outliers y hacernos una idea de cuánto suelen durar las partidas.

```{r}
# Barplot del tiempo inicial de las partidas

counts <- table(chess$time)
barplot(prop.table(counts),col="blue", main="Tiempo de partidas",xlab ="Tiempo (min)", ylab = "Porcentaje", ylim=c(0,0.5) )
```
Observamos que casi el 50% de las partidas duran 10 minutos por jugador. Además, vemos que hay algunas que tienen asignadas una duración inicial de 0 minutos; esto podría indicar que son partidas relámpago que únicamente cuentan con el tiempo de incremento después de cada jugada. Por ello, en caso de observar partidas de 0 minutos iniciales con 0 segundos de incremento, serán consideradas como outliers y se descartarán.



```{r}
# Buscamos partidas co 0 minutos iniciales y 0 segundos de incremento

which(chess$time == 0 & chess$increment == 0)
```
Ninguna partida tiene asignada 0 minutos iniciales con 0 segundos de incremento, por lo que podremos suponer que todas las partidas tienen un tiempo razonable para ser jugadas en función de la modalidad. Así pues, crearemos una nueva variable *modality* en la que categorizaremos las partidas según el tiempo inicial asignado a cada jugador (e ignorando los incrementos por jugada):

- **Partida relámpago**: tiempo inicial < 10 minutos por jugador (*modality* = Light)
- **Partida rápida**: tiempo inicial entre 10-60 minutos por jugador (*modality* = Fast)
- **Partida clásica**: tiempo inicial mayor a 60 minutos por jugador (*modality* = Classic)

Esta clasificación la hemos escogido según la web de las leyes oficiales del ajedrez:

https://web.archive.org/web/20021204101135/http://handbook.fide.com/handbook.cgi?level=E&level=E1&level=01&


```{r}
# Categorizamos las partidas según la modalidad (partida relámpago, rápida o clásica)

chess$modality <- NA
chess$modality[chess$time < 10] <- "Light"
chess$modality[chess$time >= 10 & chess$time <= 30] <- "Fast"
chess$modality[chess$time > 30] <- "Classic"
```


En segundo lugar, nos dispondremos a crear una nueva variable *duration* que nos indique el tiempo de duración total de la partida, ya que tenemos dos columnas que nos hablan acerca del instante de inicio y final de la misma en formato Unix. No hemos de confundir esta variable con la creada anteriormente *time*, ya que *duration* nos hablará de los segundos transcurridos entre el inicio y final de la partida, la cual puede aplazarse incluso por varios días. 


```{r}
# Creación de la variable time para saber la duración de la partida mediante difftime 

time_begin <- as.POSIXct.numeric(chess$created_at, origin = "1970-01-01")
time_end <- as.POSIXct.numeric(chess$last_move_at, origin = "1970-01-01")
chess$duration <- difftime(time_end, time_begin)
table(chess$duration == 0)
```
Observamos que hay 8548 registros en los que la duración de la partida no se registró, o es nula. Podemos considerar esto como un valor centinela o como una carencia en la recolección de datos de esas determinadas partidas. A su vez, inspeccionaremos los valores más altos de la variable *duration* a fin de determinar qué duraciones de partidas podemos considerar exageradamente altas y por tanto enmascarar dichos registros.


```{r}
table(chess$duration[chess$duration >= 10000000])
```
Vemos que existen 734 registros con valor de 1e+07 segundos (~116 días). Esto se podría considerar algo habitual en ciertas partidas en determinados torneos o eventos de ajedrez en los que pueden posponerse o pausarse durante días; en las variables temporales que disponemos únicamente se tiene en cuenta el instante inicial y final de la partida, pero no el tiempo de juego. No obstante, la existencia de tantos registros con este valor concreto (1e+07) nos hace pensar que es un valor centinela o atípico pese existir otros 14 registros con mayores valores de duración de partida. 

Por lo tanto, puesto que nos interesará obtener información relativa a las condiciones de victoria según la duración de la partida, enmascaremos todos los datos con  registro de tiempo nulo o mayor a 10000000 segundos para evitar outliers. Así mismo, si la partida dura más de 8 horas se asumirá automáticamente que fue pospuesta en diferentes tandas.


```{r}
# Nos quedamos únicamente con aquellas duraciones de partida nulas o mayores a 1e+07 secs
chess <- subset(chess, chess$duration > 0 & chess$duration < 10000000)
```

```{r}
chess$duration <- as.integer(chess$duration)
```


A continuación, inspeccionaremos las variables cualitativas *rated*, *victory_status*, *winner* y *increment_code* a fin de categorizar sus valores y detectar posibles fallos que sanear.


```{r chunck5}
# Comprobamos qué valores toman las diferentes variables cualitativas rated

table(chess["rated"])
```

Vemos que los valores que toma *rated* son 2. Así pues, reescribiremos los valores *True* y *False* en mayúsculas.


```{r}
# Cambiamos los valores True y False a mayúsculas

chess$rated[chess$rated == "True"] <- "TRUE"
chess$rated[chess$rated == "False"] <- "FALSE"
table(chess["rated"])
```
Ahora tenemos dos únicos valores de *rated*: 8717 partidas son competitivas y 2045 son amistosas.


```{r}
# Comprobamos qué valores toman las diferentes variables cualitativas victory_status y winner

table(chess["victory_status"])
table(chess["winner"])
```

Observamos que *victory_status* solo toma 4 valores bien definidos según el tipo de victoria que haya habido (tablas, jaque mate, agotamiento de tiempo y abandono), siendo la más frecuente el abandono-rendición (resign). Así mismo, la variable *winner* toma solo 3 valores en función de quién haya ganado: black, white y draw (empate), existiendo una superioridad de 566 partidas ganadas por el jugador blanco.

Apreciamos que las variables *victory_status* y *winner* parecen contradecirse cuando toman el valor draw, pues toma valores de 511 y 532, respectivamente, cuando deberían dar lo mismo. A continuación, mostraremos los registros que difieren el valor draw en estas dos variables para determinar cuál puede ser la causa de esta aparente contradicción.


```{r}
# Mostramos los registros que difieren de los valores draw en las variables victory_status y winner

chess.draw <- subset(chess, chess$victory_status != "draw" & chess$winner == "draw")
table(chess.draw[c("victory_status", "winner")])
```

Observamos que en todos los casos las variables *winner* = *draw* mientras que *victory_status* = *outoftime*. Además, hay un total de 21 registros con esta condición, que es justamente lo que marca la diferencia entre las apariciones de los valores *draw* en ambas variables (511 apariciones de *draw* en *victory_status* y 532 apariciones de *draw* en *winner*). Es decir, hay 21 registros en los que, pese a que el final de partida haya ocurrido por agotamiento de tiempo, el resultado ha quedado en tablas (empate). Así pues, a fin de facilitar el análisis, cambiaremos los valores *outoftime* de estos 21 registros por *draw*.


```{r}
# En los registros en los que las variables victory_status = outoftime y winner = draw,
# cambiaremos el valor outoftime por draw.

chess$victory_status[chess$victory_status == "outoftime" & chess$winner == "draw"] <- "draw"
table(chess["victory_status"])
table(chess["winner"])
```

Vemos que ahora sí coinciden la cantidad de apariciones *draw* en las variables *victory_status* y *winner*.

Las demás variables categóricas (*id*, *white_id*, *black_id*, *opening_eco*, *opening_name*) asumiremos que no es necesaria una limpieza debido a que no existen valores perdidos.


A continuación, mostramos los parámetros estadísticos básicos de las variables cuantitativas (media, mediana, rango y cuantiles) para hacernos una idea de la distribución de los datos, así como asegurarnos que no haya ningún dato fuera de rango:


```{r}
# Inspección variables cuantitativas

summary(chess[c("created_at", "last_move_at", "turns", "white_rating", "black_rating", "moves", "opening_ply")])
```

```{r}
# Mostramos la distribución de las variables white_rating y black_rating con un boxplot

boxplot(chess$white_rating,
        chess$black_rating,
        col=c('white', 'grey'),
        main='Distribución del ELO según color',
        ylab='',
        names=c("Blanco", "Negro"))
```

Del gráfico boxplot anterior podemos observar que tanto la mediana como los rangos intercuartílicos de *white_rating* y *black_rating* toman valores muy semejantes (medianas de 1594 y 1587, respectivamente; rangos intercuartílicos de 1426-1808 y 1421-1802, respectivamente), por lo que vamos a suponer que ambas variables siguen distribuciones iguales y son aptas para compararlas entre ellas. Además, se observa que no existen valores centinela o atípicos, pues el rango de las variables abarcan valores con significado real (*white_rating* tiene 784 de mínimo y 2700 de máximo, mientras que *black_rating* tiene 789 de mínimo y 2621 de máximo), por lo que no enmascaremos ningún valor según estas consideraciones.



## Construcción del conjunto de datos final


Así pues, para que nuestro set de datos sea más fácil de manipular y en aras de mejorar la objetividad del análisis, nos centraremos únicamente en aquellas partidas (una partida = un registro) cuyos participantes tengan una diferencia pequeña de puntuación ELO a fin de suponer que ambos tienen el mismo nivel y juegan con igualdad de condiciones. Además, siguiendo este criterio también podremos despreciar otros factores personales, tales como efectos psicológicos que puedan alterar el resultado de la partida (como por ejemplo, la intimidación por jugar contra alguien con mucha más experiencia, o la falta de seriedad por parte de alguien muy superior y que basa toda su partida en experimentar jugadas y/o técnicas que perturbarían el análisis).


Por ello, vamos a crear una nueva variable *diff* que nos indicará la diferencia de puntuación ELO entre 2 jugadores. En decir, calcularemos la diferencia entre *white_rating* y *black_rating* tal que un resultado positivo de +200 indicaría que el jugador blanco tiene 200 puntos más de ELO que el jugador negro.


```{r chunck6}
# Creación de la variable diff

chess$diff <- chess$white_rating - chess$black_rating
```

Cremos una nueva variable dicotómica *diff_num* que tomará 3 posibles valores en función de la diferencia de ELO de los jugadores, tal que:

- *diff_num* = 1 si *diff* > 0
- *diff_num* = 0 si *diff* = 0
- *diff_num* = -1 si *diff* < 0


```{r}
# Creación de la variable diff_num

chess$diff_num <- NA
chess$diff_num[chess$diff > 0] <- 1 
chess$diff_num[chess$diff == 0] <- 0
chess$diff_num[chess$diff < 0] <- -1
```


Creamos una nueva variable *winner_num* a la que le asignaremos valores numéricos según el valor que tome *winner*, tal que:

- *winner_num* = 1 si *winner* = white
- *winner_num* = 0 si *winner* = draw
- *winner_num* = -1 si *winner* = black


```{r}
# Creación de la variable winner_num

chess$winner_num <- NA
chess$winner_num[chess$winner == "white"] <- 1 
chess$winner_num[chess$winner == "draw"] <- 0
chess$winner_num[chess$winner == "black"] <- -1
```


A continuación, crearemos una función que hará una selección de un dataset que discrimina todos aquellos registros cuyos jugadores tengan una diferencia de ELO mayor a la indicada. Además, nos dará información de la covarianza entre las variables dicotómicas *winner_num* y *diff_num*.


```{r chunck7}
# Función que genera un subset con los registros en que los jugadores tengan una diferencia de ELO
# menor o igual a la indicada en dif_rat

min_rating <- function(df, dif_rat){
  
  y <- df[df$diff <= dif_rat & df$diff >= -dif_rat,]
  
  print(cov(y$winner_num, y$diff_num))
  print(length(y$winner_num))
  
  return(y)
}
```

Veamos ahora con qué dataset nos quedamos; nos interesará aquel que sea suficientemente grande y tenga una covarianza pequeña entre *winner_num* y *diff_num*, ya que implicará que podremos suponer que las victorias no se deben tanto por la diferencia de ELO entre jugadores, sino debido a otros factores que estudiaremos posteriormente.


```{r chunck8}
# Covarianza y número de registros de sub_dataset con diferencias de ELO menores a 2000
chess.reduced.1 <- min_rating(chess, 2000)
```

```{r}
# Covarianza y número de registros de sub_dataset con diferencias de ELO menores a 1000
chess.reduced.2 <- min_rating(chess, 1000)
```

```{r}
# Covarianza y número de registros de sub_dataset con diferencias de ELO menores a 500
chess.reduced.3 <- min_rating(chess, 500)
```

```{r}
# Covarianza y número de registros de sub_dataset con diferencias de ELO menores a 300
chess.reduced.4 <- min_rating(chess, 300)
```

```{r}
# Covarianza y número de registros de sub_dataset con diferencias de ELO menores a 200
chess.reduced.5 <- min_rating(chess, 200)
```


```{r}
# Covarianza y número de registros de sub_dataset con diferencias de ELO menores a 150
chess.reduced.6 <- min_rating(chess, 150)
```


```{r}
# Covarianza y número de registros de sub_dataset con diferencias de ELO menores a 100
chess.reduced.7 <- min_rating(chess, 100)
```

```{r}
# Covarianza y número de registros de sub_dataset con diferencias de ELO menores a 50
chess.reduced.8 <- min_rating(chess, 50)
```

```{r}
# Covarianza y número de registros de sub_dataset con diferencias de ELO menores a 25
chess.reduced.9 <- min_rating(chess, 25)
```

```{r}
# Covarianza y número de registros de sub_dataset con diferencias de ELO menores a 10
chess.reduced.10 <- min_rating(chess, 10)
```

En vista de los resultados obtenidos de las covarianzas de las variables *winner_num* y *diff_num*, podemos determinar la dependencia de condición de victoria según la diferencia de puntuación ELO de los jugadores. Así pues, observamos que existe una covarianza de 29.2% cuando la diferencia de ELO es de 2000, hasta una covarianza de 2.1% cuando la diferencia de ELO es de 10. Decidimos quedarnos con el sub_dataset *chess.reduced.8* y usarlo para el resto del estudio, pues nos ofrece una covarianza bastante baja (**8.5%**) con un alto número de registros (**4942**).


```{r}
# Renombramos el dataset *chess.reduced.8* para usarlo más cómodamente a lo largo de la práctica
chess <- chess.reduced.7
```


Ahora tenemos un nuevo set de datos *chess* con el que poder trabajar más cómodamente debido a la reducción de registros y en el que podemos suponer igualdad de condiciones entre los diferentes jugadores (todos ellos con ELO semejante de 50 o menos puntos de diferencia).  



## Análisis exploratorio


Con la limpieza de datos realizada, ya podremos inspeccionar algunas características de las diferentes variables a fin de comprobar las tendencias que condicionan la victoria de cada jugador.

Veremos ahora la proporción de partidas ganadas de cada jugador.

```{r}
# Distribución de victorias totales
table(chess["winner"])

```

```{r}

counts <- table(chess$winner)
barplot(prop.table(counts),
        col=c("black", "grey", "white"),
        ylim=c(0,1), 
        main="Distribución de victorias totales según jugador",
        xlab="Jugador",
        ylab="Porcentaje" )

grid(ny=10)

```
Aproximadamente ambos jugadores tienen la misma proporción de victorias, aunque el blanco presenta una ligera superioridad. A continuación, veremos cómo se comporta esta tendencia según la duración inicial de la partida.


```{r}
# Cantidad de victorias de cada jugador en partidas relámpago

chess.r <- chess[chess$modality == "Light",]

ggplot(chess.r, aes(x = chess.r$time, fill = chess.r$winner, colour = chess.r$winner)) + 
  geom_histogram(alpha = 0.7, position = "dodge", bins = 10) +
  ggtitle("Victorias en partidas relámpago") +
  guides(fill = guide_legend(title = "Jugador ganador"),
         colour = guide_legend(title = "Jugador ganador"))

```


```{r}
# Cantidad de victorias de cada jugador en partidas rápidas

chess.r <- chess[chess$modality == "Fast",]

ggplot(chess.r, aes(x = chess.r$time, fill = chess.r$winner, colour = chess.r$winner)) + 
  geom_histogram(alpha = 0.7, position = "dodge", bins = 20) +
  ggtitle("Victorias en partidas rápidas") +
  guides(fill = guide_legend(title = "Jugador ganador"),
         colour = guide_legend(title = "Jugador ganador"))

```

```{r}
# Cantidad de victorias de cada jugador en partidas clásicas

chess.r <- chess[chess$modality == "Classic",]

ggplot(chess.r, aes(x = chess.r$time, fill = chess.r$winner, colour = chess.r$winner)) + 
  geom_histogram(alpha = 0.7, position = "dodge", bins = 20) +
  ggtitle("Victorias en partidas clásicas") +
  guides(fill = guide_legend(title = "Jugador ganador"),
         colour = guide_legend(title = "Jugador ganador"))

```
```{r}

summary(chess$modality=="Classic")

```

Vemos que la tendencia de victoria es más o menos homogénea en las tres modalidades. En las rápidas y clásicas observamos que hay superioridad por parte del jugador blanco, aunque en las clásicas hay poca estadística para poder sacar conclusiones firmes pues solo disponemos de 109 datos.





Ahora veremos cuál es la proporción de victorias según cómo suelan acabar las partidas (*victory_status*).


```{r}

table(chess["victory_status"])

```


```{r}
# Victorias por jaque mate

counts <- table(chess$winner[chess$victory_status == "mate"])
barplot(prop.table(counts),
        col=c("black", "white"),
        ylim=c(0,1), 
        main="Distribución de victorias por jaque mate",
        xlab="Jugador",
        ylab="Porcentaje" )

grid(ny=10)

```
```{r}
# Victorias por abandono

counts <- table(chess$winner[chess$victory_status == "resign"])
barplot(prop.table(counts),
        col=c("black", "white"),
        ylim=c(0,1), 
        main="Distribución de victorias por abandono",
        xlab="Jugador",
        ylab="Porcentaje" )

grid(ny=10)

```

```{r}
# Victorias por agotar el tiempo

counts <- table(chess$winner[chess$victory_status == "outoftime"])
barplot(prop.table(counts),
        col=c("black", "white"),
        ylim=c(0,1), 
        main="Distribución de victorias por agotar el tiempo",
        xlab="Jugador",
        ylab="Porcentaje" )

grid(ny=10)

```

Aunque en todos los casos haya una ligera superioridad de victoria por parte del jugador blanco, esta es prácticamente despreciable en el caso de agotamiento de tiempo. Cuando la partida acaba por jaque mate o abandono, vemos más claramente una tendencia del blanco a ganar.


Nos interesará saber también qué modalidad se suele jugar con mayor frecuencia en las partidas competitivas y amistosas.


```{r}
# Modalidad en partidas competitivas

counts <- table(chess$modality[chess$rated == "TRUE"])
barplot(prop.table(counts),
        col=c("brown", "blue" ,"yellow"),
        ylim=c(0,1), 
        main="Modalidad de juego predominante en partidas competitivas",
        xlab="Jugador",
        ylab="Porcentaje" )

grid(ny=10)

```

```{r}
# Modalidad en partidas amistosas

counts <- table(chess$modality[chess$rated == "FALSE"])
barplot(prop.table(counts),
        col=c("brown", "blue" ,"yellow"),
        ylim=c(0,1), 
        main="Modalidad de juego predominante en partidas amistosas",
        xlab="Jugador",
        ylab="Porcentaje" )

grid(ny=10)

```

Aunque el cambio de tendencia sea pequeño, observamos que hay menos partidas jugadas en modalidad rápida (fast) cuando se tratan de partidas amistosas, aumentando en estas los casos en partidas relámpago (light) y clásicas.

Veremos ahora qué jugador suele ganar en partidas relámpago según sean amistosas o competitivas.

```{r}
# Partidas relámpago competitivas 

counts <- table(chess$winner[chess$modality == "Light" & chess$rated == "TRUE"])
barplot(prop.table(counts),
        col=c("black", "grey", "white"),
        ylim=c(0,1), 
        main="Victorias en partidas competitivas y modalidad relámpago",
        xlab="Jugador",
        ylab="Porcentaje" )

grid(ny=10)

```

```{r}
# Partidas relámpago amistosas

counts <- table(chess$winner[chess$modality == "Light" & chess$rated == "FALSE"])
barplot(prop.table(counts),
        col=c("black", "grey", "white"),
        ylim=c(0,1), 
        main="Victorias en partidas amistosas y modalidad relámpago",
        xlab="Jugador",
        ylab="Porcentaje" )

grid(ny=10)

```

Observamos que hay más casos en los que el jugador negro gana partidas relámpago cuando se trata de partidas amistosas.


Veremos ahora qué jugador suele ganar en partidas rápidas según sean amistosas o competitivas.

```{r}
# Partidas rápidas competitivas

counts <- table(chess$winner[chess$modality == "Fast" & chess$rated == "TRUE"])
barplot(prop.table(counts),
        col=c("black", "grey", "white"),
        ylim=c(0,1), 
        main="Victorias en partidas competitivas y modalidad rápida",
        xlab="Jugador",
        ylab="Porcentaje" )

grid(ny=10)

```

```{r}
# Partidas rápidas amistosas

counts <- table(chess$winner[chess$modality == "Fast" & chess$rated == "FALSE"])
barplot(prop.table(counts),
        col=c("black", "grey", "white"),
        ylim=c(0,1), 
        main="Victorias en partidas amistosas y modalidad rápida",
        xlab="Jugador",
        ylab="Porcentaje" )

grid(ny=10)

```
Se observa que la tendencia a conseguir la victoria apenas varía en las partidas rápidas, habiendo en ambas una superioridad apreciable por parte del jugador blanco.

Veremos ahora qué jugador suele ganar en partidas clásicas según sean amistosas o competitivas.


```{r}
# Partidas clásicas competitivas

counts <- table(chess$winner[chess$modality == "Classic" & chess$rated == "TRUE"])
barplot(prop.table(counts),
        col=c("black", "grey", "white"),
        ylim=c(0,1), 
        main="Victorias en partidas competitivas y modalidad clásica",
        xlab="Jugador",
        ylab="Porcentaje" )

grid(ny=10)

```


```{r}
# Partidas clásicas amistosas

counts <- table(chess$winner[chess$modality == "Classic" & chess$rated == "FALSE"])
barplot(prop.table(counts),
        col=c("black", "grey", "white"),
        ylim=c(0,1), 
        main="Victorias en partidas amistosas y modalidad clásica",
        xlab="Jugador",
        ylab="Porcentaje" )

grid(ny=10)

```

En esta ocasión, observamos una clara superioridad por parte del jugador blanco, siendo mayor en las partidas amistosas. No obstante, recordemos que al disponer solo de 109 partidas en la modalidad clásica no podremos sacar conclusiones firmes sobre la gran diferencia existente entre ambos jugadores. 






## Normalización

Normalizaremos las variables numéricas de nuestro dataset para asegurarnos que todas ellas contribuyen por igual en nuestro análisis.


```{r}
# Definimos la función de normalización
nor <-function(x) { (x -min(x))/(max(x)-min(x))}

# Guardamos un nuevo dataset normalizado

chess.n <- chess
chess.n$type <- NULL

n = c("turns", "white_rating", "black_rating", "opening_ply", "time", "increment", "duration", "diff")

chess.n <- chess.n %>% select(all_of(n))

chess.nor <- as.data.frame(lapply(chess.n, nor))

head(chess.nor)

```



## Proceso PCA


Aplicamos el análisis de componentes principales (PCA) para hacernos una mejor idea de la variabilidad del set de datos según los atributos que disponemos.


```{r}

chess.pca <- prcomp(chess.nor)
summary(chess.pca)

```

Con esto sabemos qué atributos influyen más en la varianza del conjunto total de datos: el que más contribuye es el primer atributo con un 0.4420 de varianza, y el que menos es el octavo atributo con ~ 0 de varianza. 

Haremos un histograma para visualizar el peso de cada atributo.


```{r}

get_eig(chess.pca)

```

```{r}

fviz_eig(chess.pca)

```

Vemos que el primer atributo adquiere un 44% de peso, el segundo 29%, el tercero 11%, el cuarto 7%, el quinto 5%, el sexto 2% y los dos restantes tienen menos del 1%.

Para saber qué variables escogemos, aplicamos el método de Káiser y nos quedaremos únicamente con aquellas que tengan una varianza superior a 1. Pero antes, escalaremos las variables:


```{r}
# Escalamos los datos
chess.nor_scale <- scale(chess.nor)

# Calculamos las componentes principales
chess.pca_scale <- prcomp(chess.nor_scale)

# Mostramos la varianza de dichas variables:
var_acc_scale <- chess.pca_scale$sdev^2
var_acc_scale

```

Aplicando el método de Káiser, nos quedaremos con los 4 primeros componentes principales, pues sus varianzas son mayores a la unidad. Con los datos escalados, mostraremos el histograma con el peso de varianza:



```{r}
# Histograma del peso de los componentes con los datos escalados

fviz_eig(chess.pca_scale)

```
```{r}
# Mostramos valores propios y porcentaje de varianza de los datos escalados

get_eig(chess.pca_scale)

```


Las 4 primeras dimensiones arrojan valores propios mayores a la unidad, por lo que estas representan más varianza que las variables originales. Aplicando Káiser, seleccionamos los 4 componentes principales:



```{r}
# Mostramos resultados PCA de las variables

var <- get_pca_var(chess.pca_scale)
var
```

Usando las 4 componentes principales escogidas, veremos cómo se relacionan con nuestras variables

```{r}
# Accedemos a $cood que nos habla de las coordenadas de variables para hacer
# un diagrama de dispersión
head(var$coord[,1:4],11)

```

```{r}
# Accedemos al $cos2 que nos representa la calidad de representación de las
# variables al mapa de factores
head(var$cos2[,1:4],11)

corrplot(var$cos2[,1:4], is.corre=FALSE)

```

Atendiendo a los valores de cos2, vemos que en la 1ª Componente principal las variables *white_rating* y *black_rating* están bien representadas, mientras que en la 2ª componente predominan *time* y *increment*, en la 3ª predomina *turns* y en la 4ª destaca *diff*. Esto significa que en esas dimensiones nuestras variables están bien representadas. También observamos que *opening_ply* no lo está en ninguna dimensión.



```{r}

fviz_pca_var(chess.pca_scale,
col.var = "cos2",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE

)

```
Por la representación *fviz_pca_var* podemos observar que las variables *diff*, *opening_ply* y *turns* son las que peor representadas están para los primeros componentes, mientras que *white_rating* es la que lo está mejor.


Finalmente, estudiaremos las contribuciones de las variables en la contabilización de la variabilidad en un determinado componente principal. Esto nos permitirá eliminar las variables con una poca contribución en las dos primeras dimensiones (o componentes principales) a fin de simplificar el modelo.



```{r}
# Accedemos a los valores de las contribuciones de cada variable

head(var$contrib[,1:4],11)

corrplot(var$contrib[,1:4], is.cor=FALSE)

```

En la gráfica de correlación siguiente mostraremos qué variables son más importantes para describir el modelo;


```{r}

fviz_pca_var(chess.pca_scale, col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)

```

A la vista de los gráficos anteriores, queda claro que las variables más importantes (contribuyen más al modelo) son *white_rating*, *black_rating*, *time*, *increment* y *duration*. Las variables que apuntan a lados opuestos significa que no están nada correlacionadas, como es el caso de *increment* y *diff*.

Como cabía esperar de nuestra limpieza de dataset realizada anteriormente, la variable *diff* no contribuye prácticamente al modelo. Esto se debe a que nos hemos quedado con un dataset reducido en el que los jugadores tienen una diferencia de puntuación ELO de 50 y, como se comentó antes, apenas es relevante esta diferencia para determinar quién ganará la partida.





## Conclusiones


Los datos estudiados contemplan 20056 partidas de ajedrez recolectados de Lichess.org en el que todos los jugadores tienen una determinada puntuación ELO y disputan partidas tanto amistosas (la victoria no altera su puntuación) como competitivas (quien gana, sube puntuación ELO, y quien pierde baja su puntuación). 

Como habría sido esperable, aquellas partidas con gran diferencia de puntuación ELO habrían podido provocar alteraciones en el análisis, tales como la tendencia a jugar de manera "experimental" por parte de un jugador muy superior al contrincante, o la tendencia al abandono por parte de un jugador de nivel muy inferior. Por ello, hemos decidido reducir el tamaño de nuestro dataset a tan solo 4942 registros con tal que no exista una diferencia superior a 100 puntos ELO entre jugadores. Esto implica que solo exista un 8% de covarianza entre la condición de victoria según la puntuación ELO de los jugadores; en comparación al ~30% de covarianza ofrecida por el dataset original.

Con el dataset reducido, nos hemos dispuesto a inspeccionar los distintos comportamientos de las variables según diferentes criterios. De manera general, hemos comprobado que hay más porcentaje de partidas totales en las que el jugador blanco se alza con la victoria. Observamos claramente esta tendencia en las partidas de modalidad rápida y clásica (ya sean amistosas o competitivas); el jugador negro únicamente cuenta con más victorias en las partidas relámpago amistosas. Esto podría deberse a que en las partidas relámpago la apertura no es tan importante al tratarse de jugadas que responden a un pensamiento rápido e improvisado, más que por pura estrategia a largo plazo, por lo que la ventaja del jugador blanco al ser quien empieza la partida podría no ser tan relevante en esta modalidad.

También hemos observado que la mayor cantidad de finales de partida se deben a la rendición por parte de uno de los contrincantes, siendo el jugador negro el que más se rinde. En cuanto a la condición de victoria por jaque mate, el blanco también tiene superioridad, mientras que cuando se debe a agotamiento de tiempo, ambos rivales tienen unas tendencias similares.

Finalmente, en lo que respecta al análisis de componentes principales, hemos observado que las variables más relevantes para el análisis del modelo son *white_rating*, *black_rating*, *time*, *increment* y *duration* (en orden descendente), mientras que las que menos han resultado ser *opening_ply*, *turns* y *diff*. Esto nos indica que la condición de victoria por parte de alguno de los jugadores se verá más determinada, en primer lugar, por las puntuaciones de cada uno de ellos, por el tiempo que disponen (con incremento) y la duración total de la partida, ya que el hecho de que haya sido pospuesta para otro día puede influir mucho en el resultado debido a que los jugadores pueden ser ayudados por terceras personas, o programas informáticos, y retomar la partida con otra perspectiva renovada. Por otra parte, *opening_ply* y *turns* no parecen tener una relevancia tan grande a la hora de condicionar una victoria, pues el número de turnos y el número de jugadas de la apertura son únicas de cada partida y dependen exclusivamente del factor humano únicamente durante el transcurso del juego. La variable *diff*, sin embargo, no tiene apenas relevancia en los dos componentes principales debido a que se ha hecho una reducción del dataset en aras de mejorar la igualdad de condiciones entre los distintos jugadores.

Concluimos con que se puede apreciar una clara tendencia a que el jugador blanco gane las partidas, pues la ventaja que dispone al empezarlas puede condicionar el resto del juego. Varios factores que alteran este condicionamiento son el tiempo de partida (e incremento), el ELO de cada jugador y la duración total (si se ha aplazado o no a otro instante del inicial).









